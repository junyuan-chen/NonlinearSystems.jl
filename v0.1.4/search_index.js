var documenterSearchIndex = {"docs":
[{"location":"man/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Suppose the system of nonlinear equations of interest can be described as follows:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using NonlinearSystems\n\n# Residual function\nfunction f!(F, x)\n    F[1] = (x[1] + 3) * (x[2]^3 - 7) + 18\n    F[2] = sin(x[2] * exp(x[1]) - 1)\n    return F\nend\n\n# Jacobian function (optional)\nfunction j!(J, x)\n    J[1,1] = x[2]^3 - 7\n    J[1,2] = 3 * x[2]^2 * (x[1] + 3)\n    u = exp(x[1]) * cos(x[2] * exp(x[1]) - 1)\n    J[2,1] = x[2] * u\n    J[2,2] = u\n    return J\nend\n\n# Initial value\nx0 = [0.1, 1.2]\nnothing # hide","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To solve the above equations as a root-finding problem, we specify the Hybrid algorithm by passing either Hybrid or Hybrid{RootFinding} as the first argument:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"# Evaluate Jacobians via finite differencing methods from FiniteDiff.jl\nsolve(Hybrid, f!, x0)\n# Use user-specified Jacobian function and separate out the initialization step\ns = init(Hybrid, f!, j!, x0)\nsolve!(s)\nnothing # hide","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The last line from above calls a non-allocating method solve! that mutates the pre-allocated problem s in-place. On Julia REPL, the essential information is summarized as follows:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"s","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The solution can be retrieved by accessing the corresponding field:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"s.x","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"In general, a nonlinear system of equations may have multiple solutions or no solution. If only solutions that fall in certain regions are of interest, we may impose lower and upper bounds that force the solver to only seek solution candidates within the bounded areas:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"solve(Hybrid, f!, ones(2), lower=fill(0.5,2), upper=fill(2.0,2))","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that we have found a different solution in the above example.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"In practice, we often do not expect the existence of solutions that solve the equations exactly as identities. Instead, we may solve a least-squares problem that minimizes the Euclidean norm of residuals. To do so, simply specify the algorithm type as Hybrid{LeastSquares}:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"s = solve(Hybrid{LeastSquares}, f!, x0)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that the gradient norm is NaN. For this specific problem, convergence is attained before the gradient is ever evaluated.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nA root-finding algorithm requires that the number of variables matches the number of equations. That is, the associated Jacobian matrix must be a square matrix. In contrast, a least-squares algorithm does not impose this restriction.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To inspect the solver iteration, summary information can be printed for each evaluation:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"s = solve(Hybrid{LeastSquares}, f!, x0, showtrace=1);","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that all relevant information is collected in a single object:","category":"page"},{"location":"man/getting-started/#NonlinearSystems.NonlinearSystem","page":"Getting Started","title":"NonlinearSystems.NonlinearSystem","text":"NonlinearSystem(::Type{P}, fdf::OnceDifferentiable, x, fx, dx, solver; kwargs...)\n\nConstruct a NonlinearSystem for holding all information used for solving a nonlinear system of equations with problem type P. Users are not expected to use this method directly but should instead call init or solve to generate the problem. Any keyword argument passed to init or solve that is not accepted by a specific solution algorithm is passed to the constructor of NonlinearSystem. For the relevant solution algorithms, see Hybrid.\n\nKeywords\n\nlower::Union{AbstractVector, Nothing}=nothing: element-wise lower bounds for solution candidates.\nupper::Union{AbstractVector, Nothing}=nothing: element-wise upper bounds for solution candidates.\nmaxiter::Integer=1000: maximum number of iteration allowed before terminating.\nftol::Real=1e-8: absolute tolerance for the infinity norm of residuals fx.\ngtol::Real=1e-10: absolute tolerance for the infinity norm of gradient vector; only relevant for solving least squares.\nxtol::Real=0.0: absolute tolerance for the infinity norm of a step dx.\nxtolr::Real=0.0: relative tolerance for the infinity norm of a step dx as a proportion of x.\nshowtrace::Union{Bool,Integer}=false: print summary information for each trial made by the solver; with showtrace=true, information is printed once every 20 iterations; an interger value specifies the gap for printing.\n\n\n\n\n\n","category":"type"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Instead of calling solve or solve!, which simply iterates NonlinearSystem in a loop, we may manually iterate the solver steps as follows:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"s = init(Hybrid{LeastSquares}, f!, x0);\ns.solver\niterate(s)\ns.solver","category":"page"},{"location":"man/solver-options/#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"man/solver-options/","page":"Solver Options","title":"Solver Options","text":"In addition to specifying a solution algorithm, solver behavior can be adjusted by passing the relevant keyword arguments to init or solve.","category":"page"},{"location":"man/solver-options/#Trust-Region-Methods","page":"Solver Options","title":"Trust Region Methods","text":"","category":"section"},{"location":"man/solver-options/#NonlinearSystems.Hybrid","page":"Solver Options","title":"NonlinearSystems.Hybrid","text":"Hybrid{P} <: AbstractAlgorithm{P}\n\nA modified version of Powell's hybrid method (a trust region method with dogleg). The essentially same algorithm can solve both root-finding problems and least-squares problem. To indicate the problem type, set either RootFinding or LeastSquares as type parameter. For keyword arguments accepted by init and solve when using this algorithm, see HybridSolver.\n\nReferences\n\nMorÃ©, Jorge J., Danny C. Sorenson, Burton S. Garbow, and Kenneth E. Hillstrom. 1984. \"The MINPACK Project.\" In Sources and Development of Mathematical Software, ed. Wayne R. Cowell, 88-111. New Jersey: Prentice-Hall.\nNocedal, Jorge, and Stephen J. Wright. 2006. Numerical Optimization. 2nd ed. New York: Springer.\nPowell, Michael J. D. 1970. \"A Hybrid Method for Nonlinear Equations.\" In Numerical Methods for Nonlinear Algebraic Equations, ed. Philip Rabinowitz, 87-114. London: Gordon and Breach.\n\n\n\n\n\n","category":"type"},{"location":"man/solver-options/#NonlinearSystems.HybridSolver","page":"Solver Options","title":"NonlinearSystems.HybridSolver","text":"HybridSolver(fdf::OnceDifferentiable, x, fx, J, P; kwargs...)\n\nConstruct HybridSolver for solving a problem of type P with Hybrid method. Users are not expected to call this method directly but should pass keyword arguments to init or solve instead. See also Hybrid.\n\nKeywords\n\nlinsolver=default_linsolver(fdf, x0, P): solver for the underlying linear problems.\nfactor_init::Real=1.0: a factor for scaling the initial trust region radius.\nfactor_up::Real=2.0: a factor for expanding the trust region radius.\nfactor_down::Real=0.5: a factor for shrinking the trust region radius.\nscaling::Bool=true: allow improving the scaling of trust region.\nrank1update::Bool=true: allow using rank-1 update for the Jacobian matrix and factorization.\nthres_jac::Integer=2: recompute the Jacobian matrix if the trust region is shrinked consecutively by the specified number of times; setting a non-positive value results in recomputing the Jacobian matrix after each step.\nthres_nslow1::Integer=10: signal slow solver progress if the reduction in residual norm remains small for the specified number of consecutive steps.\nthres_nslow2::Integer=5: signal slow solver progress if there is no expansion of trust region after recomputing the Jacobian matrix in the specified number of consecutive steps.\nwarn::Bool=true: print a warning message for slow solver progress\n\n\n\n\n\n","category":"type"},{"location":"man/solver-options/#Linear-Solvers-for-Subproblems","page":"Solver Options","title":"Linear Solvers for Subproblems","text":"","category":"section"},{"location":"man/solver-options/","page":"Solver Options","title":"Solver Options","text":"Documentation for specifying the linear solvers will be added in future.","category":"page"},{"location":"#NonlinearSystems.jl","page":"Home","title":"NonlinearSystems.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation site for NonlinearSystems.jl!","category":"page"},{"location":"","page":"Home","title":"Home","text":"NonlinearSystems.jl is a Julia package for solving nonlinear systems of equations and nonlinear least squares. It renovates well-trusted solution algorithms with highly performant and extensible implementation in native Julia language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NonlinearSystems.jl places special emphasis on","category":"page"},{"location":"","page":"Home","title":"Home","text":"Low number of evaluations needed for updating the Jacobian matrix\nFlexibility of swapping the underlying linear solvers based on array type and hardware\nZero memory allocation incurred in iteration steps","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this moment, the only solution algorithm implemented is a modified version of Powell's hybrid method (a trust region method with dogleg).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NonlinearSystems.jl can be installed with the Julia package manager Pkg. From the Julia REPL, type ] to enter the Pkg REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add NonlinearSystems","category":"page"}]
}
